# 进制的转换

- 二进制
- 八进制
- 十进制
- 十六进制

## 二进制转换

二进制可以简单的转为**八进制, 十进制, 十六进制**
我们假设一个二进制为: 11011, 我们看看是如何转化的

1. 八进制
| 1 1 | 0 11|
|------|------|
| 3 | 3 |
| 每三个二进制相加|

2. 十进制
| 1 | 1 | 0 | 1 | 1 |
|--|--|--|--|--|
|16|8|4|2|1|

3. 十六进制
与八进制类似, 每**四个二进制相加**

## 十进制转化换

通常会吧进制转为**二进制**然后转为其他进制

# 原码, 反码, 补码

## 原码

为**整数的二进制**形式

## 反码

1. 正数的反码为本身
2. 负数的反码0->1, 1->0

## 补码

1. 正数的补码为本身
2. 负数的补码为反码加一

# 移动运算符
- 左移操作符int b = ( a << 1_)具有乘2的效果[ 左移1位, 右补1位0 ]❗注意一定是整数
```C
int a = 6;
int b = (a << 1);
printf("%d\n", b);//b = 12
```
- 右移操作符( 常见的是算术右移 )
- 如果是负数,具有除2效果,[右移一位,前面补1 ]; ❗不要移负数位,这是未定义
```C
int a = 6;
int b = (a >> 1);
printf("%d\n", b);//b = 3
```

# 位操作符

## 位操作符&(按位与), |(按位或), ^(按位异或), ~(按位取反)

- 按位与( a & b ),取两个整数的补数相加,有零取零,无零取1
- 按位或 只要有1则为1,无1则为零
- 按位异或 相同为零,相异为1
- 按位取反 对单个整数进行取反❗**必须都是整数**

## 变量交换

1. 创建临时变量
```C
int a = 3;
int b = 5;
int c = 0;//创建变量c

c = a;
a = b;
b = c;
```

2. 利用按位异或变量交换
```C
int a = 3;
int b = 5;

a = a ^ b;//a ^ a = 0
b = a ^ b;//b = a ^ b ^ b
a = a ^ b;//a = a ^ a ^ b
```
一般情况下都用**第一种**情况**因为可读性高**

## 计算二进制中一的个数

### 利用&1来计算二进制个数

例如13的二进制为00000000 00000000 00000000 00001101
     1的二进制为00000000 00000000 00000000 00000001
 **把最后的数用&来求出1的个数, 然后再把13的二进制向右移一位
 代码如下1
 ```C
 int n = 0;
scanf("%d", &n);
int count = 0;
int i = 0;
for (i = 0; i < 32; i++)
{
	if (((n >> i) & 1) == 1)
	{
		count++;
	}
}
printf("%d\n", count);
 ```
 因为整形int为32bit,需要0<i<32

### 利用n&(n-1)计算二进制1的个数

```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
	int n = 0;
	scanf("%d", & n);
	int count = 0;
	while (n)
	{
		n = n & (n - 1);
		count++;
	}
	printf("%d\n", count);

	return 0;
}
```
**通过以下方式实现
n = 15                 1111
n-1=14                1110
n                          1110

n-1                      1101
n                         1100

n-1                      1011
n                         1000

n-1                      0111
n                         0000

## 利用按位或|来二进制置0或置1

例子:
```
//13的二进制序列:      00000000 00000000 00000000 00001101
//将1的二进制移动4位 : 00000000 00000000 00000000 00010000
// 按位或|
//将二进制序列改为 :   00000000 00000000 00000000 00011101
//将1二进制移动4位取~: 11111111 11111111 11111111 11101111
//按位与&
```
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
	int a = 13;
	int b = 1 << 4;
	a = a | b;
	printf("%d\n", a);

	b = ~b;
	a = a & b;
	printf("%d\n", a);

	return 0;
}
```

# 单目操作符
```
!, ++, --, &, *, +, -, ~, sizeof(类型)
```

- !表示否定
- ++分为前置和后置
- --分为前置和后置
- +为加号
- -为减号
- sizeof(数据类型)可算空间大小
- ~按位取反

# 逗号表达式

概念: 由逗号隔开的多个表达式,从**左向右依次执行**,**整个表达式的结果是最后一个表达式的结果**
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
	int a = 1;
	int b = 2;
	int c = (a = b + 10, a, b = a + 1);

	printf("%d\n", c);//c = 13

	return 0;
}
```

```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
    a = get_val();
    count_val(a);
    while(a > 0)
    {
         a = get_val();
         count_val(a);
    }
	return 0;
}```
可简化为逗号表达式
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
    a = get_val();
    count_val(a);
    while(a = get_val(), count_val(a), a > 0)
    {
        
    }
	return 0;
}```

# 下表访问[], 函数调用()
## 下表引用操作符
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
    int arr[10] = {3, 4, 7, 8, 9, 10, 48};
    printf("%d\n",arr[3]);//打印8
    return 0;
}
```

## 函数调用操作符
**接受一个或者多个操作符**: 第一个操作数是传递给**函数的参数**
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int Add(int x, int y)
{
    return x + y;
}

void main()
{
    printf("hehe\n");
}

int main()
{
    printf("hehe\n");
    int ret = (2, 3);//函数
    test();//操作符
    return 0;
}
```


# 结构成员访问操作符

## 结构体与操作符

### 定义:
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

struct Student
{
    char name[20];
    int age;
    int high;
    float weight;
    int id[16];
}s4, s5, s6;
//s4, s5, s6是结构体全局变量

int main()
{
    struct Student s1 = { "张三", 20, 180, 75.5f, 1234567890 };//初始化
    struct Student s2 = { .age = 30, .name = "李四", .weight = 80.5f, .high = 177,  .id = 1234567891 };//不按顺序排的,前面要加.
    printf("%s %d %d %.1f %d\n", s1.name, s1.age, s1.high, s1.weight, s1.id);
        //struck Student s3;
        //s1, s2, s3是结构体的局部变量
        return 0;
}
```

# 整形提升

在表达式中各种长度可能小于int的整形, 都要有整型提升,如:char和short
1. 有符号整数提升是按照变量的数据类型的符号位来提升的
2. 无符号整数提升, 高位补0
```C
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main()
{
	char a = 127;
	//00000000 00000000 00000000 01111111
	//0111111 -a
	char b = 3;
	//00000000 00000000 00000000 00000011
	//00000011 -b
	char c = a + b;
	//00000000 00000000 00000000 01111111
	//00000000 00000000 00000000 00000011
	//00000000 00000000 00000000 10000010
	//10000010
	//
	//%d - 以十进制的形式打印有符号的整数
	//11111111 11111111 11111111 10000010补码
	//10000000 00000000 00000000 01111101反码
	//10000000 00000000 00000000 01111110原码
	printf("%d\n", c);
	return 0;
}
```


# 算术转换

若两个变量不同的类型相加或相减, 要转换类型
```C
int a = 5;
double b = 3.23
```

#  运算符的优先级

## 错误代码
```c
c + --c;
```

```C
a*b + b*c + c*d;
```




























